#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <map>
#include <set>
#include <algorithm>
#include <sstream>
#include "lexer.hpp"

// Forward declaration
std::string preprocess(const std::string& source, const std::string& currentDir = "", const std::vector<std::string>& includePaths = {});

enum OpCode {
    HALT = 0x00, PUSH_INT = 0x01, PUSH_STR = 0x02, SYSCALL = 0x03, 
    STORE = 0x04, LOAD = 0x05, ADD = 0x06, SUB = 0x07, MUL = 0x08, DIV = 0x09,
    JMP = 0x0A, JZ = 0x0B, CALL = 0x0C, RET = 0x0D,
    FOR_ITER = 0x0E, TRY_ENTER = 0x0F, TRY_EXIT = 0x10, RAISE = 0x11,
    MOD = 0x12, LSHIFT = 0x13, RSHIFT = 0x14, BIT_AND = 0x15, BIT_OR = 0x16, BIT_XOR = 0x17, BIT_NOT = 0x18,
    EQ = 0x19, NE = 0x1A, LT = 0x1B, LE = 0x1C, GT = 0x1D, GE = 0x1E,
    LOGIC_AND = 0x1F, LOGIC_OR = 0x20, LOGIC_NOT = 0x21,
    MALLOC = 0x50, FREE = 0x51, READ_ADDR = 0x52, WRITE_ADDR = 0x53, ADDR_OF = 0x54
};

struct Field { std::string name; int offset; };
struct Type { std::string name; int size; bool isPointer; std::vector<Field> fields; };

class Compiler {
public:
    Compiler(const std::vector<Token>& tokens, bool verbose = false) : tokens(tokens), pos(0), verbose(verbose) {
        types["int"] = {"int", 4, false};
        types["char"] = {"char", 1, false};
        types["void"] = {"void", 0, false};
        types["FILE"] = {"void*", 4, true};
        types["const"] = {"void", 0, false};
        types["size_t"] = {"int", 4, false};
        types["string"] = {"string", 4, false};
        types["Task"] = {"void", 0, false};
        types["var"] = {"void", 0, false};
        types["bool"] = {"bool", 1, false};
        types["_Bool"] = {"bool", 1, false};
        types["double"] = {"double", 8, false};
        types["float"] = {"float", 4, false};
        types["time_t"] = {"int", 4, false};
        types["Point"] = {"Point", 8, false, {{"x", 0}, {"y", 4}}};
        types["IntFloat"] = {"IntFloat", 4, false, {{"i", 0}, {"f", 0}}};
        types["Color"] = {"int", 4, false};
        // C++ scalar types
        types["short"] = {"short", 2, false};
        types["long"] = {"long", 4, false};
        types["signed"] = {"int", 4, false};
        types["unsigned"] = {"unsigned", 4, false};
        types["wchar_t"] = {"wchar_t", 2, false};
        types["char8_t"] = {"char8_t", 1, false};
        types["char16_t"] = {"char16_t", 2, false};
        types["char32_t"] = {"char32_t", 4, false};
        // Advanced Data Structures
        types["set"] = {"set", 4, true};
        types["dict"] = {"dict", 4, true};
        types["deque"] = {"deque", 4, true};
        types["queue"] = {"queue", 4, true};
        types["heap"] = {"heap", 4, true};
        types["tuple"] = {"tuple", 4, true};
    }

    std::vector<uint8_t> compile() {
        if (verbose) std::cout << "Starting compilation..." << std::endl;
        while (pos < tokens.size() && tokens[pos].type != TokenType::END_OF_FILE) {
            parseTopLevel();
        }
        std::string entry = symbolTable.count("main") ? "main" : (symbolTable.count("Main") ? "Main" : "");
        if (entry != "") { 
            if (verbose) std::cout << "Entry point found: " << entry << std::endl;
            emitOp(CALL); emitString(entry); 
        }
        emitOp(HALT);
        return bytecode;
    }

private:
    std::vector<Token> tokens;
    size_t pos;
    std::vector<uint8_t> bytecode;
    std::map<std::string, int> symbolTable;
    std::map<std::string, Type> types;
    std::string modulePrefix; 
    bool verbose;

    bool isDeclModifier(const std::string& v) {
        static std::set<std::string> mods = {
            "static", "extern", "public", "private", "async", "readonly", "sealed", "typedef",
            "alignas", "alignof", "asm", "auto", "const", "consteval", "constexpr", "constinit",
            "explicit", "export", "inline", "mutable", "register", "thread_local", "virtual", "volatile",
            "template", "typename", "concept", "requires", "noexcept", "friend",
            "restrict",
            "_Alignas", "_Alignof", "_Atomic", "_Bool", "_Complex", "_Generic", "_Imaginary",
            "_Noreturn", "_Static_assert", "_Thread_local", "typeof", "typeof_unqual"
        };
        return mods.count(v);
    }

    void skipAlignasAlignof() {
        if (pos >= tokens.size()) return;
        const std::string& v = tokens[pos].value;
        if (v != "alignas" && v != "alignof" && v != "_Alignas" && v != "_Alignof") return;
        pos++;
        if (pos < tokens.size() && tokens[pos].type == TokenType::LPAREN) {
            pos++; int depth = 1;
            while (pos < tokens.size() && depth > 0) {
                if (tokens[pos].type == TokenType::LPAREN) depth++;
                else if (tokens[pos].type == TokenType::RPAREN) depth--;
                pos++;
            }
        }
    }

    void skipStaticAssert() {
        if (pos >= tokens.size()) return;
        const std::string& v = tokens[pos].value;
        if (v != "static_assert" && v != "_Static_assert") return;
        pos++;
        if (pos < tokens.size() && tokens[pos].type == TokenType::LPAREN) {
            pos++; int depth = 1;
            while (pos < tokens.size() && depth > 0) {
                if (tokens[pos].type == TokenType::LPAREN) depth++;
                else if (tokens[pos].type == TokenType::RPAREN) depth--;
                pos++;
            }
            if (pos < tokens.size() && tokens[pos].type == TokenType::SEMICOLON) pos++;
        }
    }

    void skipTypeof() {
        if (pos >= tokens.size()) return;
        const std::string& v = tokens[pos].value;
        if (v != "typeof" && v != "typeof_unqual") return;
        pos++;
        if (pos < tokens.size() && tokens[pos].type == TokenType::LPAREN) {
            pos++; int depth = 1;
            while (pos < tokens.size() && depth > 0) {
                if (tokens[pos].type == TokenType::LPAREN) depth++;
                else if (tokens[pos].type == TokenType::RPAREN) depth--;
                pos++;
            }
        }
    }

    std::string mangle(const std::string& name) const {
        return modulePrefix.empty() ? name : modulePrefix + name;
    }

    void parseTopLevel() {
        if (pos >= tokens.size()) return;
        if (verbose && tokens[pos].type != TokenType::INDENT && tokens[pos].type != TokenType::DEDENT) 
            std::cout << "Parsing: " << tokens[pos].value << " at line " << tokens[pos].line << std::endl;
        
        if (tokens[pos].value == "__module__") {
            pos++;
            if (pos < tokens.size()) { modulePrefix = tokens[pos++].value + "."; }
            return;
        }
        if (tokens[pos].value == "__endmodule__") {
            pos++; modulePrefix.clear();
            if (pos < tokens.size() && tokens[pos].type == TokenType::SEMICOLON) pos++;
            return;
        }
        while (pos < tokens.size() && isDeclModifier(tokens[pos].value)) {
            const std::string& v = tokens[pos].value;
            if (v == "alignas" || v == "alignof" || v == "_Alignas" || v == "_Alignof") { skipAlignasAlignof(); continue; }
            if (v == "static_assert" || v == "_Static_assert") { skipStaticAssert(); continue; }
            if (v == "typeof" || v == "typeof_unqual") { skipTypeof(); continue; }
            pos++;
        }
        if (pos >= tokens.size()) return;
        Token t = tokens[pos];

        if (t.type == TokenType::KEYWORD || t.type == TokenType::IDENTIFIER) {
            if (t.value == "using" || t.value == "import" || t.value == "module" || t.value == "export") {
                pos++; while(pos < tokens.size() && tokens[pos].type != TokenType::SEMICOLON) pos++;
                if (pos < tokens.size()) pos++; return;
            }
            if (t.value == "namespace" || t.value == "class" || t.value == "struct" || t.value == "union" || t.value == "enum") {
                pos++; if (pos < tokens.size() && tokens[pos].type == TokenType::IDENTIFIER) pos++;
                if (pos < tokens.size() && tokens[pos].type == TokenType::LBRACE) {
                    pos++; while(pos < tokens.size() && tokens[pos].type != TokenType::RBRACE) parseTopLevel();
                    if (pos < tokens.size()) pos++; if (pos < tokens.size() && tokens[pos].type == TokenType::SEMICOLON) pos++;
                }
                return;
            }
            if (t.value == "def" || types.count(t.value)) {
                parseDeclaration(); return;
            }
        }
        parseStatement();
    }

    std::string parseTypeName() {
        std::string typeName;
        static std::set<std::string> typeSpec = {"unsigned", "signed", "long", "short", "char", "char8_t", "char16_t", "char32_t", "wchar_t", "int", "float", "double", "void", "bool", "_Bool"};
        while (pos < tokens.size() && typeSpec.count(tokens[pos].value)) {
            if (!typeName.empty()) typeName += " ";
            typeName += tokens[pos++].value;
        }
        if (typeName.empty() && pos < tokens.size() && (tokens[pos].type == TokenType::KEYWORD || tokens[pos].type == TokenType::IDENTIFIER)) {
            typeName = tokens[pos++].value;
        }
        return typeName;
    }

    int getTypeSize(const std::string& typeName) {
        if (types.count(typeName)) return types[typeName].size;
        if (typeName.find("double") != std::string::npos) return 8;
        if (typeName.find("float") != std::string::npos) return 4;
        if (typeName.find("short") != std::string::npos) return 2;
        if (typeName.find("long") != std::string::npos) return 4;
        if (typeName.find("char") != std::string::npos && typeName.find("32") != std::string::npos) return 4;
        if (typeName.find("char") != std::string::npos && typeName.find("16") != std::string::npos) return 2;
        if (typeName.find("char") != std::string::npos) return 1;
        if (typeName.find("wchar") != std::string::npos) return 2;
        if (typeName.find("unsigned") != std::string::npos || typeName.find("signed") != std::string::npos || typeName.find("int") != std::string::npos) return 4;
        return 4;
    }

    void parseDeclaration() {
        std::string typeName = parseTypeName();
        if (typeName.empty()) return;
        while (pos < tokens.size() && (tokens[pos].type == TokenType::STAR || tokens[pos].value == "?")) pos++;
        std::string name = pos < tokens.size() ? tokens[pos++].value : "";
        if (name.empty()) return;

        std::string sym = mangle(name);
        if (pos < tokens.size() && tokens[pos].type == TokenType::LPAREN) {
            // Function
            pos++; while(pos < tokens.size() && tokens[pos].type != TokenType::RPAREN) pos++; pos++;
            if (pos < tokens.size() && tokens[pos].type == TokenType::COLON) pos++; 

            int startPlace = bytecode.size();
            emitPushInt(0); emitOp(STORE); emitString(sym);
            int skipJump = bytecode.size(); emitJump(JMP, 0);

            int bodyStart = bytecode.size();
            symbolTable[sym] = bodyStart;
            patchInt(startPlace + 1, bodyStart);

            parseBlock();
            emitOp(RET);
            patchInt(skipJump + 1, bytecode.size());
        } else {
            // Variable (including package constants)
            if (pos < tokens.size() && tokens[pos].type == TokenType::LBRACKET) {
                pos++; if (pos < tokens.size() && tokens[pos].type == TokenType::RBRACKET) pos++;
            }
            if (pos < tokens.size() && tokens[pos].type == TokenType::EQUALS) {
                pos++;
                if (tokens[pos].type == TokenType::LBRACE) {
                    pos++; int i = 0;
                    while(pos < tokens.size() && tokens[pos].type != TokenType::RBRACE) {
                        parseExpression();
                        if (types.count(typeName) && i < types[typeName].fields.size()) {
                            std::string m = sym + "." + types[typeName].fields[i++].name;
                            emitOp(STORE); emitString(m);
                        } else { emitOp(STORE); emitString(sym + "[" + std::to_string(i++) + "]"); }
                        if (tokens[pos].type == TokenType::COMMA) pos++;
                    }
                    if (pos < tokens.size()) pos++;
                } else {
                    parseExpression(); emitOp(STORE); emitString(sym);
                }
            }
            if (pos < tokens.size() && tokens[pos].type == TokenType::SEMICOLON) pos++;
        }
    }

    void parseBlock() {
        if (pos < tokens.size() && (tokens[pos].type == TokenType::INDENT || tokens[pos].type == TokenType::LBRACE)) {
            TokenType end = (tokens[pos].type == TokenType::INDENT) ? TokenType::DEDENT : TokenType::RBRACE;
            pos++; while (pos < tokens.size() && tokens[pos].type != end) parseTopLevel();
            if (pos < tokens.size()) pos++;
        } else parseTopLevel();
    }

    void parseStatement() {
        if (pos >= tokens.size()) return;
        Token t = tokens[pos++];
        if (t.value == "if") {
            if (tokens[pos].type == TokenType::LPAREN) pos++;
            parseExpression(); if (tokens[pos].type == TokenType::RPAREN) pos++;
            emitOp(JZ); int patch = bytecode.size(); emitInt(0);
            parseBlock();
            while (pos < tokens.size() && (tokens[pos].value == "elif" || tokens[pos].value == "else")) {
                if (tokens[pos].value == "elif") {
                    pos++; int skipElif = bytecode.size(); emitJump(JMP, 0);
                    patchInt(patch, bytecode.size());
                    if (tokens[pos].type == TokenType::LPAREN) pos++;
                    parseExpression(); if (tokens[pos].type == TokenType::RPAREN) pos++;
                    emitOp(JZ); patch = bytecode.size(); emitInt(0);
                    parseBlock();
                    patchInt(skipElif + 1, bytecode.size());
                } else {
                    pos++; int skipElse = bytecode.size(); emitJump(JMP, 0);
                    patchInt(patch, bytecode.size());
                    parseBlock();
                    patchInt(skipElse + 1, bytecode.size());
                    break;
                }
            }
            patchInt(patch, bytecode.size());
            return;
        }
        if (t.value == "return") { parseExpression(); emitOp(RET); if (pos < tokens.size() && tokens[pos].type == TokenType::SEMICOLON) pos++; return; }
        if (t.value == "yield") { parseExpression(); if (pos < tokens.size() && tokens[pos].type == TokenType::SEMICOLON) pos++; return; }
        // Python: pass (no-op), del, global, nonlocal, with, assert
        if (t.value == "pass") { if (pos < tokens.size() && tokens[pos].type == TokenType::SEMICOLON) pos++; return; }
        if (t.value == "del" || t.value == "global" || t.value == "nonlocal") {
            while (pos < tokens.size() && tokens[pos].type != TokenType::SEMICOLON) pos++;
            if (pos < tokens.size()) pos++; return;
        }
        if (t.value == "with") {
            while (pos < tokens.size() && tokens[pos].type != TokenType::COLON) pos++;
            if (pos < tokens.size()) pos++; parseBlock(); return;
        }
        if (t.value == "assert") {
            parseExpression();
            emitOp(JZ); int patchAssert = bytecode.size(); emitInt(0);
            if (pos < tokens.size() && tokens[pos].type == TokenType::COMMA) { pos++; parseExpression(); }
            int abortAddr = bytecode.size();
            emitPushInt(1); emitSyscall(0xE0);
            patchInt(patchAssert, abortAddr);
            if (pos < tokens.size() && tokens[pos].type == TokenType::SEMICOLON) pos++;
            return;
        }
        // C++ / Python control flow: skip break/continue/switch/case/default/do/lambda/async/await/match
        if (t.value == "break" || t.value == "continue" || t.value == "switch" || t.value == "case" || t.value == "default" || t.value == "do" || t.value == "lambda" || t.value == "async" || t.value == "await" || t.value == "match") {
            while (pos < tokens.size() && tokens[pos].type != TokenType::SEMICOLON && tokens[pos].type != TokenType::COLON) pos++;
            if (pos < tokens.size() && tokens[pos].type == TokenType::COLON) { pos++; parseBlock(); }
            else if (pos < tokens.size()) pos++;
            return;
        }
        // Catch-all: any other keyword at statement start (C/C++/Python) â€” skip until ; or :
        if (t.type == TokenType::KEYWORD) {
            while (pos < tokens.size() && tokens[pos].type != TokenType::SEMICOLON && tokens[pos].type != TokenType::COLON) pos++;
            if (pos < tokens.size() && tokens[pos].type == TokenType::COLON) { pos++; parseBlock(); }
            else if (pos < tokens.size()) pos++;
            return;
        }
        pos--;
        if (types.count(tokens[pos].value)) { parseDeclaration(); return; }
        parseExpression();
        if (pos < tokens.size() && tokens[pos].type == TokenType::SEMICOLON) pos++;
    }

    std::string parseExpression(int minPrecedence = 0) {
        std::string leftName = parsePrimary();
        while (pos < tokens.size()) {
            Token op = tokens[pos];
            int prec = getPrecedence(op);
            if (prec < minPrecedence || prec == -1) break;
            pos++;
            if (op.type == TokenType::COLON_EQUALS) {
                // Walrus: name := expr
                if (!leftName.empty()) {
                    parseExpression(prec + 1);
                    emitOp(STORE); emitString(mangle(leftName));
                    emitOp(LOAD); emitString(mangle(leftName));
                    leftName = ""; 
                }
                continue; 
            }
            parseExpression(prec + 1);
            emitBinaryOp(op.type);
            leftName = ""; 
        }
        return ""; 
    }

    int getPrecedence(Token t) {
        switch (t.type) {
            case TokenType::LOR: return 1;
            case TokenType::LAND: return 2;
            case TokenType::PIPE: return 3;
            case TokenType::CARET: return 4;
            case TokenType::AMPERSAND: return 5;
            case TokenType::EQUALS_EQUALS: case TokenType::NOT_EQ: return 6;
            case TokenType::LT: case TokenType::LE: case TokenType::GT: case TokenType::GE: return 7;
            case TokenType::LSHIFT: case TokenType::RSHIFT: return 8;
            case TokenType::PLUS: case TokenType::MINUS: return 9;
            case TokenType::STAR: case TokenType::SLASH: case TokenType::MOD: return 10;
            case TokenType::COLON_EQUALS: return 0;
            default: return -1;
        }
    }

    void emitBinaryOp(TokenType type) {
        switch (type) {
            case TokenType::PLUS: emitOp(ADD); break;
            case TokenType::MINUS: emitOp(SUB); break;
            case TokenType::STAR: emitOp(MUL); break;
            case TokenType::SLASH: emitOp(DIV); break;
            case TokenType::EQUALS_EQUALS: emitOp(EQ); break;
            case TokenType::NOT_EQ: emitOp(NE); break;
            case TokenType::LT: emitOp(LT); break;
            case TokenType::LE: emitOp(LE); break;
            case TokenType::GT: emitOp(GT); break;
            case TokenType::GE: emitOp(GE); break;
            case TokenType::LAND: emitOp(LOGIC_AND); break;
            case TokenType::LOR: emitOp(LOGIC_OR); break;
            case TokenType::AMPERSAND: emitOp(BIT_AND); break;
            case TokenType::PIPE: emitOp(BIT_OR); break;
            case TokenType::CARET: emitOp(BIT_XOR); break;
            case TokenType::MOD: emitOp(MOD); break;
            case TokenType::LSHIFT: emitOp(LSHIFT); break;
            case TokenType::RSHIFT: emitOp(RSHIFT); break;
            default: break;
        }
    }

    std::string parsePrimary() {
        if (pos >= tokens.size()) return "";
        Token t = tokens[pos++];
        if (t.type == TokenType::FSTRING_PART) {
            emitOp(PUSH_STR); emitString(t.value);
            return "";
        }
        if (t.type == TokenType::LBRACE_EXP) {
            parseExpression();
            if (pos < tokens.size() && tokens[pos].type == TokenType::RBRACE_EXP) pos++;
            emitOp(SYSCALL); bytecode.push_back(0xEF); // str() conversion
            return "";
        }
        // C++ nullptr
        if (t.type == TokenType::KEYWORD && t.value == "nullptr") {
            emitPushInt(0);
            return "";
        }
        // C++ sizeof(type) or sizeof expr
        if (t.type == TokenType::KEYWORD && t.value == "sizeof") {
            if (pos < tokens.size() && tokens[pos].type == TokenType::LPAREN) {
                pos++;
                std::string saveType = parseTypeName();
                if (pos < tokens.size() && tokens[pos].type == TokenType::RPAREN) pos++;
                emitPushInt(getTypeSize(saveType));
            } else {
                std::string saveType = parseTypeName();
                emitPushInt(getTypeSize(saveType));
            }
            return "";
        }
        // Unary * (pointer dereference)
        if (t.type == TokenType::STAR) {
            parseExpression();
            emitOp(READ_ADDR);
            bytecode.push_back(4);
            return "";
        }
        // Unary & (address-of)
        if (t.type == TokenType::AMPERSAND) {
            parseExpression();
            return "";
        }
        if (t.type == TokenType::KEYWORD && t.value == "true") { emitPushInt(1); return ""; }
        if (t.type == TokenType::KEYWORD && t.value == "false") { emitPushInt(0); return ""; }
        if (t.type == TokenType::INTEGER) { 
            try { emitPushInt(std::stoi(t.value)); } catch(...) { emitPushInt(0); }
            return "";
        }
        else if (t.type == TokenType::STRING) { emitOp(PUSH_STR); emitString(t.value); return ""; }
        else if (t.type == TokenType::IDENTIFIER) {
            std::string name = t.value;
            while (pos < tokens.size() && (tokens[pos].type == TokenType::DOT || tokens[pos].type == TokenType::ARROW)) {
                pos++; name += "." + tokens[pos++].value;
            }
            if (pos < tokens.size() && tokens[pos].type == TokenType::LPAREN) {
                pos++; int count = 0;
                while(pos < tokens.size() && tokens[pos].type != TokenType::RPAREN) { parseExpression(); count++; if(tokens[pos].type == TokenType::COMMA) pos++; }
                pos++;
                
                if (name == "fopen") { emitPushInt(count); emitSyscall(0x70); }
                else if (name == "fprintf") { emitPushInt(count); emitSyscall(0x71); }
                else if (name == "fclose") { emitPushInt(count); emitSyscall(0x72); }
                else if (name == "printf" || name == "print") { emitPushInt(count); emitSyscall(0x60); }
                else if (name == "ctime") { emitPushInt(count); emitSyscall(0x81); }
                else if (name == "Console.WriteLine") { emitPushInt(count); emitSyscall(0x60); emitOp(PUSH_STR); emitString("\\n"); emitPushInt(1); emitSyscall(0x60); }
                else if (name == "len") { emitPushInt(count); emitSyscall(0x63); }
                else if (name == "range") { emitPushInt(count); emitSyscall(0xE8); }
                else if (name == "min") { emitPushInt(count); emitSyscall(0xE9); }
                else if (name == "max") { emitPushInt(count); emitSyscall(0xEA); }
                else if (name == "sum") { emitPushInt(count); emitSyscall(0xEB); }
                else if (name == "sorted") { emitPushInt(count); emitSyscall(0xEC); }
                else if (name == "int" || name == "Integer") { emitPushInt(count); emitSyscall(0xED); }
                else if (name == "float" || name == "Double") { emitPushInt(count); emitSyscall(0xEE); }
                else if (name == "str" || name == "String") { emitPushInt(count); emitSyscall(0xEF); }
                else if (name == "bool") { emitPushInt(count); emitSyscall(0xF0); }
                else if (name == "tuple") { emitPushInt(count); emitSyscall(0xF1); }
                else if (name == "chr") { emitPushInt(count); emitSyscall(0xF2); }
                else if (name == "ord") { emitPushInt(count); emitSyscall(0xF3); }
                else if (name == "round") { emitPushInt(count); emitSyscall(0xF4); }
                else if (name == "divmod") { emitPushInt(count); emitSyscall(0xF5); }
                else if (name == "pow") { emitPushInt(count); emitSyscall(0xF6); }
                else if (name == "all") { emitPushInt(count); emitSyscall(0xF7); }
                else if (name == "any") { emitPushInt(count); emitSyscall(0xF8); }
                else if (name == "repr") { emitPushInt(count); emitSyscall(0xF9); }
                else if (name == "bin") { emitPushInt(count); emitSyscall(0xFA); }
                else if (name == "hex") { emitPushInt(count); emitSyscall(0xFB); }
                else if (name == "oct") { emitPushInt(count); emitSyscall(0xFC); }
                else if (name == "input") { emitPushInt(count); emitSyscall(0xFD); }
                else if (name == "zip") { emitPushInt(count); emitSyscall(0xFE); }
                else if (name == "enumerate") { emitPushInt(count); emitSyscall(0xFF); }
                else if (name == "reversed") { emitPushInt(count); emitSyscall(0xC9); }
                else if (name == "open") { emitPushInt(count); emitSyscall(0x70); }
                else if (name == "strlen") { emitPushInt(count); emitSyscall(0x63); }
                else if (name == "puts") { emitPushInt(count); emitSyscall(0x61); }
                else if (name == "__random") { emitPushInt(count); emitSyscall(0xCA); }
                else if (name == "malloc") { emitPushInt(count); emitSyscall(0xD0); }
                else if (name == "calloc") { emitPushInt(count); emitSyscall(0xD1); }
                else if (name == "realloc") { emitPushInt(count); emitSyscall(0xD2); }
                else if (name == "free") { emitPushInt(count); emitSyscall(0xD3); }
                else if (name == "atof") { emitPushInt(count); emitSyscall(0xD4); }
                else if (name == "atoi") { emitPushInt(count); emitSyscall(0xD5); }
                else if (name == "atol") { emitPushInt(count); emitSyscall(0xD6); }
                else if (name == "atoll") { emitPushInt(count); emitSyscall(0xD7); }
                else if (name == "strtod" || name == "strtof" || name == "strtol" || name == "strtold" || name == "strtoll" || name == "strtoul" || name == "strtoull") {
                    emitPushInt(count); emitSyscall(name == "strtod" ? 0xD8 : name == "strtof" ? 0xD9 : name == "strtol" ? 0xDA : name == "strtold" ? 0xDB : name == "strtoll" ? 0xDC : name == "strtoul" ? 0xDD : 0xDE);
                }
                else if (name == "abort") { emitPushInt(count); emitSyscall(0xE0); }
                else if (name == "exit" || name == "_Exit") { emitPushInt(count); emitSyscall(name == "_Exit" ? 0xE1 : 0xC0); }
                else if (name == "atexit") { emitPushInt(count); emitSyscall(0xE2); }
                else if (name == "at_quick_exit") { emitPushInt(count); emitSyscall(0xE3); }
                else if (name == "quick_exit") { emitPushInt(count); emitSyscall(0xE4); }
                else if (name == "getenv") { emitPushInt(count); emitSyscall(0xE5); }
                else if (name == "system") { emitPushInt(count); emitSyscall(0xC1); }
                else if (name == "bsearch") { emitPushInt(count); emitSyscall(0xE6); }
                else if (name == "qsort") { emitPushInt(count); emitSyscall(0xE7); }
                else if (name == "set") { emitSyscall(0x90); }
                else if (name == "dict") { emitSyscall(0x92); }
                else if (name == "deque" || name == "list") { emitSyscall(0x95); }
                else if (hasSuffix(name, ".append")) { callMethod(name, 7, 0x96, count); }
                else if (hasSuffix(name, ".pop")) { callMethod(name, 4, 0x98, count); }
                else if (hasSuffix(name, ".size")) { callMethod(name, 5, 0x63, count); }
                else if (name == "math.sqrt") emitSyscall(0xB0);
                else if (name == "abs") emitSyscall(0xB1);
                else if (name == "sys.exit") emitSyscall(0xC0);
                else if (name == "os.system") emitSyscall(0xC1);
                else if (name == "time.sleep") emitSyscall(0xC2);
                else { emitOp(CALL); emitString(name); }
            } else if (pos < tokens.size() && tokens[pos].type == TokenType::EQUALS) {
                pos++; parseExpression(); emitOp(STORE); emitString(mangle(name));
            } else { 
                if (name == "math.pi") { emitSyscall(0xB2); }
                else if (name == "math.e") { emitSyscall(0xB3); }
                else { std::string loadName = (name.find('.') != std::string::npos) ? name : mangle(name); emitOp(LOAD); emitString(loadName); }
            }
            return name;
        } else if (t.type == TokenType::LPAREN) {
            parseExpression();
            if (pos < tokens.size() && tokens[pos].type == TokenType::RPAREN) pos++;
            return "";
        }
        return "";
    }

    bool hasSuffix(const std::string &str, const std::string &suffix) {
        return str.size() >= suffix.size() && str.compare(str.size() - suffix.size(), suffix.size(), suffix) == 0;
    }

    void callMethod(std::string fullName, int suffixLen, uint8_t syscall, int count) {
        std::string obj = fullName.substr(0, fullName.length() - suffixLen);
        emitOp(LOAD); emitString(obj);
        emitPushInt(count);
        emitSyscall(syscall);
    }

    void emitString(const std::string& s) {
        bytecode.push_back((uint8_t)s.length());
        for (char c : s) bytecode.push_back((uint8_t)c);
    }
    void emitSyscall(uint8_t id) { emitOp(SYSCALL); bytecode.push_back(id); }
    void emitPushInt(int val) { emitOp(PUSH_INT); emitInt(val); }
    void emitOp(uint8_t op) { bytecode.push_back(op); }
    void emitJump(uint8_t op, int target) { emitOp(op); emitInt(target); }
    void emitInt(int val) {
        bytecode.push_back((val >> 24) & 0xFF); bytecode.push_back((val >> 16) & 0xFF);
        bytecode.push_back((val >> 8) & 0xFF); bytecode.push_back(val & 0xFF);
    }
    void patchInt(int pos, int val) {
        bytecode[pos] = (val >> 24) & 0xFF; bytecode[pos+1] = (val >> 16) & 0xFF;
        bytecode[pos+2] = (val >> 8) & 0xFF; bytecode[pos+3] = (val & 0xFF);
    }
};

static std::set<std::string> globalIncludedFiles;

std::string preprocess(const std::string& source, const std::string& currentDir, const std::vector<std::string>& includePaths) {
    std::string result;
    std::string line;
    std::istringstream stream(source);
    while (std::getline(stream, line)) {
        size_t importPos = line.find("import ");
        size_t includePos = line.find("#include");
        if (importPos == 0 || includePos == 0) {
            std::string mod;
            bool isImport = (importPos == 0);
            if (isImport) {
                mod = line.substr(7);
                size_t asPos = mod.find(" as ");
                size_t fromPos = mod.find(" from ");
                if (asPos != std::string::npos) mod = mod.substr(0, asPos);
                else if (fromPos != std::string::npos) mod = mod.substr(fromPos + 6);
            } else {
                size_t start = line.find_first_of("\"<");
                size_t end = line.find_last_of("\">");
                if (start != std::string::npos && end != std::string::npos && end > start) mod = line.substr(start + 1, end - start - 1);
                else continue;
            }
            size_t first = mod.find_first_not_of(" \t");
            if (first != std::string::npos) mod.erase(0, first);
            size_t last = mod.find_last_not_of(" \t");
            if (last != std::string::npos) mod.erase(last + 1);
            mod.erase(remove_if(mod.begin(), mod.end(), isspace), mod.end());
            
            if (mod == "math" || mod == "math.h" || mod == "cmath" || mod == "sys" || mod == "stdlib.h" || mod == "cstdlib" || mod == "time" || mod == "time.h" || mod == "ctime" || mod == "iostream" || mod == "stdio.h" || mod == "vector" || mod == "string" || mod == "map") continue;

            std::vector<std::string> searchPaths = { currentDir, "." };
            searchPaths.insert(searchPaths.end(), includePaths.begin(), includePaths.end());
            std::vector<std::string> attempts = { mod + "/__init__.soul", mod + "/__init__.py", mod + ".soul", mod + ".py", mod + ".h", mod + ".c", mod };

            bool found = false;
            for (const auto& path : searchPaths) {
                if (found) break;
                for (const auto& tryName : attempts) {
                    std::string fullPath = (path.empty() ? "" : path + "/") + tryName;
                    if (globalIncludedFiles.count(fullPath)) { found = true; break; }
                    std::ifstream imp(fullPath);
                    if (imp.good()) {
                        globalIncludedFiles.insert(fullPath);
                        std::string impSrc((std::istreambuf_iterator<char>(imp)), std::istreambuf_iterator<char>());
                        if (isImport) result += "__module__ " + mod + "\n" + preprocess(impSrc, path, includePaths) + "\n__endmodule__\n";
                        else result += preprocess(impSrc, path, includePaths) + "\n";
                        found = true; break;
                    }
                }
            }
        } else result += line + "\n";
    }
    return result;
}

int main(int argc, char* argv[]) {
    try {
        std::cerr << "--- SoulC START ---" << std::endl;
        std::string inputPath, outputPath;
        std::vector<std::string> includePaths;
        bool verbose = false, forcePython = false, forceCpp = false;

        if (argc < 2) {
            std::cerr << "Usage: soulc [options] <input_file>" << std::endl;
            return 1;
        }

        for (int i = 1; i < argc; ++i) {
            std::string arg = argv[i];
            if (arg == "-o" && i + 1 < argc) outputPath = argv[++i];
            else if (arg == "-I" && i + 1 < argc) includePaths.push_back(argv[++i]);
            else if (arg == "-v") verbose = true;
            else if (arg == "--python") forcePython = true;
            else if (arg == "--cpp") forceCpp = true;
            else if (arg[0] != '-') inputPath = arg;
        }

        if (inputPath.empty()) { std::cerr << "No input file specified" << std::endl; return 1; }
        if (outputPath.empty()) {
            size_t lastDot = inputPath.find_last_of(".");
            outputPath = (lastDot == std::string::npos ? inputPath : inputPath.substr(0, lastDot)) + ".casm";
        }

        std::ifstream file(inputPath);
        if (!file.good()) { std::cerr << "Cannot open input file" << std::endl; return 1; }
        std::string source((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
        std::cerr << "File read: " << source.size() << " bytes" << std::endl;
        source = preprocess(source, ".", includePaths);
        std::cerr << "Preprocessed: " << source.size() << " bytes" << std::endl;
        
        bool pythonMode = forcePython || (!forceCpp && (inputPath.find(".py") != std::string::npos || inputPath.find(".soul") != std::string::npos));
        Lexer lexer(source, pythonMode);
        Compiler compiler(lexer.tokenize(), verbose);
        auto bc = compiler.compile();
        
        std::ofstream out(outputPath, std::ios::binary);
        out.write("CASM", 4);
        out.write((char*)bc.data(), bc.size());
        if (verbose) std::cout << "Compiled successfully" << std::endl;
        return 0;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    } catch (...) {
        std::cerr << "Unknown error occurred" << std::endl;
        return 1;
    }
}
